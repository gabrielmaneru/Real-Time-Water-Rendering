#version 440
 
// PN patch data
struct PNData
{
    float b210;
    float b120;
    float b021;
    float b012;
    float b102;
    float b201;
    float b111;
};

layout(triangles, equal_spacing) in;
 
in vec3 Normal_tcs[];
in vec3 Tangent_tcs[];
in vec3 Bitangent_tcs[];
in vec2 Uv_tcs[];
in PNData PatchData[];

uniform mat4 M; 
uniform mat4 V; 
uniform mat4 P; 

out vec3 Normal_tes;
out vec3 Tangent_tes;
out vec3 Bitangent_tes;
out vec3 Position_tes;
out vec2 Uv_tes;

uniform float uTessAlpha = 1.0f;    
 
void main()
{
    vec3 b300  = gl_in[0].gl_Position.xyz;
    vec3 b030  = gl_in[1].gl_Position.xyz;
    vec3 b003  = gl_in[2].gl_Position.xyz;
    
	vec3 b210 = vec3(PatchData[0].b210,PatchData[1].b210,PatchData[2].b210);
	vec3 b120 = vec3(PatchData[0].b120,PatchData[1].b120,PatchData[2].b120);
	vec3 b021 = vec3(PatchData[0].b021,PatchData[1].b021,PatchData[2].b021);
	vec3 b012 = vec3(PatchData[0].b012,PatchData[1].b012,PatchData[2].b012);
	vec3 b102 = vec3(PatchData[0].b102,PatchData[1].b102,PatchData[2].b102);
	vec3 b201 = vec3(PatchData[0].b201,PatchData[1].b201,PatchData[2].b201);
	vec3 b111 = vec3(PatchData[0].b111,PatchData[1].b111,PatchData[2].b111);
	
	float w = gl_TessCoord[2];
	float w2 = w*w;
	float w3 = w2*w;
	
	float u = gl_TessCoord[0];
	float u2 = u*u;
	float u3 = u2*u;

	float v = gl_TessCoord[1];
	float v2 = v*v;
	float v3 = v2*v;

    vec3 finalPos = b300*w3 + b030*u3 + b003*v3
				  + b210*3*w2*u + b120*3*w*u2 + b201*3*w2*v
				  + b021*3*u2*v + b102*3*w*v2 + b012*3*u*v2
				  + b111*6*w*u*v;

    Normal_tes = gl_TessCoord[0]*Normal_tcs[0]
			   + gl_TessCoord[1]*Normal_tcs[1]
			   + gl_TessCoord[2]*Normal_tcs[2];
    Tangent_tes = gl_TessCoord[0]*Tangent_tcs[0]
			    + gl_TessCoord[1]*Tangent_tcs[1]
			    + gl_TessCoord[2]*Tangent_tcs[2];
    Bitangent_tes = gl_TessCoord[0]*Bitangent_tcs[0]
		          + gl_TessCoord[1]*Bitangent_tcs[1]
		          + gl_TessCoord[2]*Bitangent_tcs[2];
    Uv_tes = gl_TessCoord[0]*Uv_tcs[0]
		   + gl_TessCoord[1]*Uv_tcs[1]
		   + gl_TessCoord[2]*Uv_tcs[2];

	mat4 MV = V*M;
	mat3 normalMtx = inverse(transpose(mat3(MV)));

	Normal_tes = normalize(normalMtx * Normal_tes);
	Tangent_tes = normalize(normalMtx * Tangent_tes);
	Bitangent_tes = normalize(normalMtx * Bitangent_tes);

	Position_tes = (MV*vec4(finalPos, 1.0)).xyz;
	gl_Position = P*MV* vec4(finalPos, 1.0);
}