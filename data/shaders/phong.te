#version 440
 
struct PhongData
{
    float termIJ;
    float termJK;
    float termIK;
};

layout(triangles, fractional_odd_spacing, ccw) in;
 
in vec3 Normal_tcs[];
in vec3 Tangent_tcs[];
in vec3 Bitangent_tcs[];
in vec2 Uv_tcs[];
in float adapt_value_tcs[];
in PhongData PatchData[];

uniform mat4 M; 
uniform mat4 V; 
uniform mat4 P; 

out vec3 Normal_tes;
out vec3 Tangent_tes;
out vec3 Bitangent_tes;
out vec3 Position_tes;
out vec2 Uv_tes;
out float adapt_value_tes;

#define Pi gl_in[0].gl_Position.xyz
#define Pj gl_in[1].gl_Position.xyz
#define Pk gl_in[2].gl_Position.xyz
#define tc1 gl_TessCoord

uniform float alpha = 1.00;    
 
void main()
{
	vec3 tc2 = tc1*tc1;
	
vec3 termIJ = vec3(PatchData[0].termIJ, PatchData[1].termIJ, PatchData[2].termIJ);
vec3 termJK = vec3(PatchData[0].termJK, PatchData[1].termJK, PatchData[2].termJK);
vec3 termIK = vec3(PatchData[0].termIK, PatchData[1].termIK, PatchData[2].termIK);
    Normal_tes = gl_TessCoord[0]*Normal_tcs[0]
			   + gl_TessCoord[1]*Normal_tcs[1]
			   + gl_TessCoord[2]*Normal_tcs[2];
    Tangent_tes = gl_TessCoord[0]*Tangent_tcs[0]
			    + gl_TessCoord[1]*Tangent_tcs[1]
			    + gl_TessCoord[2]*Tangent_tcs[2];
    Bitangent_tes = gl_TessCoord[0]*Bitangent_tcs[0]
		          + gl_TessCoord[1]*Bitangent_tcs[1]
		          + gl_TessCoord[2]*Bitangent_tcs[2];
    Uv_tes = gl_TessCoord[0]*Uv_tcs[0]
		   + gl_TessCoord[1]*Uv_tcs[1]
		   + gl_TessCoord[2]*Uv_tcs[2];
    adapt_value_tes = gl_TessCoord[0]*adapt_value_tcs[0]
		            + gl_TessCoord[1]*adapt_value_tcs[1]
		            + gl_TessCoord[2]*adapt_value_tcs[2];



	vec3 barPos = gl_TessCoord[0]*Pi
		        + gl_TessCoord[1]*Pj
		        + gl_TessCoord[2]*Pk;
	vec3 phongPos = tc2[0]*Pi
	+tc2[1]*Pj
	+tc2[2]*Pk
	+tc1[0]*tc1[1]*termIJ
	+tc1[1]*tc1[2]*termJK
	+tc1[2]*tc1[0]*termIK;
	
	vec3 finalPos = mix(barPos,phongPos,alpha);

	mat4 MV = V*M;
	mat3 normalMtx = inverse(transpose(mat3(MV)));

	Normal_tes = normalize(normalMtx * Normal_tes);
	Tangent_tes = normalize(normalMtx * Tangent_tes);
	Bitangent_tes = normalize(normalMtx * Bitangent_tes);

	Position_tes = (MV*vec4(finalPos, 1.0)).xyz;
	gl_Position = P*MV* vec4(finalPos, 1.0);
}