#version 440

struct PhongData
{
    float termIJ;
    float termJK;
    float termIK;
};

layout(vertices=3) out;

in vec3 vNormal[];
in vec3 vTangent[];
in vec3 vBitangent[];
in vec2 vUv[];

uniform float levels = 1.0f;
uniform float lod;
uniform bool adaptive;
uniform mat4 M; 
uniform mat4 V; 

out vec3 Normal_tcs[3];
out vec3 Tangent_tcs[3];
out vec3 Bitangent_tcs[3];
out vec2 Uv_tcs[3];
out float adapt_value_tcs[3];
out PhongData PatchData[3];

#define Pi gl_in[0].gl_Position.xyz
#define Pj gl_in[1].gl_Position.xyz
#define Pk gl_in[2].gl_Position.xyz

float adapt_value(int i)
{
	mat4 C_to_M = inverse(V*M);
	vec3 cam = (C_to_M * vec4(0,0,0,1)).xyz;

	vec3 p0,p1,n0,n1;
	if(i == 0)
	{
		p0 = gl_in[1].gl_Position.xyz;
		p1 = gl_in[2].gl_Position.xyz;
		n0 = vNormal[1];
		n1 = vNormal[2];
	}
	else if(i == 1)
	{
		p0 = gl_in[2].gl_Position.xyz;
		p1 = gl_in[0].gl_Position.xyz;
		n0 = vNormal[2];
		n1 = vNormal[0];
	}
	else // 2
	{
		p0 = gl_in[0].gl_Position.xyz;
		p1 = gl_in[1].gl_Position.xyz;
		n0 = vNormal[0];
		n1 = vNormal[1];
	}

	vec3 mid_p = mix (p0,p1,0.5);
	vec3 mid_n = normalize(mix(n0,n1,0.5));

	float dot_pc = dot(mid_n, normalize(cam-mid_p));
	return 1.0-abs(dot_pc);
}

float adapt_value_all()
{
	mat4 C_to_M = inverse(V*M);
	vec3 cam = (C_to_M * vec4(0,0,0,1)).xyz;

	vec3 p0 = gl_in[0].gl_Position.xyz;
	vec3 p1 = gl_in[1].gl_Position.xyz;
	vec3 p2 = gl_in[2].gl_Position.xyz;
	vec3 n0 = vNormal[0];
	vec3 n1 = vNormal[1];
	vec3 n2 = vNormal[2];

	vec3 mid_p = (p0+p1+p2)/3.0;
	vec3 mid_n = normalize(n0+n1+n2);

	float dot_pc = dot(n0, normalize(cam-p0));
	return 1.0-abs(dot_pc);
}



float PI_i(int i, vec3 q)
{
	vec3 qp = q - gl_in[i].gl_Position.xyz;
	return q[gl_InvocationID] - dot(qp, vNormal[i]) * vNormal[i][gl_InvocationID];
}

void main()
{
    // pass data
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	
    Normal_tcs[gl_InvocationID] = vNormal[gl_InvocationID];
    Tangent_tcs[gl_InvocationID] = vTangent[gl_InvocationID];
    Bitangent_tcs[gl_InvocationID] = vBitangent[gl_InvocationID];
    Uv_tcs[gl_InvocationID] = vUv[gl_InvocationID];
	
	PatchData[gl_InvocationID].termIJ = PI_i(0,Pj) + PI_i(1,Pi);
	PatchData[gl_InvocationID].termJK = PI_i(1,Pk) + PI_i(2,Pj);
	PatchData[gl_InvocationID].termIK = PI_i(2,Pi) + PI_i(0,Pk);

    // set tess levels
	float d =adapt_value(gl_InvocationID);
	mat4 C_to_M = inverse(V*M);
	vec3 cam = (C_to_M * vec4(0,0,0,1)).xyz;
	float len = length(cam-gl_in[gl_InvocationID].gl_Position.xyz);
	float lvls = levels / max(len/lod, 1.0);
	if(adaptive)
	{
		gl_TessLevelOuter[gl_InvocationID] = d*lvls;
		gl_TessLevelInner[0] = adapt_value_all()*lvls;
	}
	else
	{
		gl_TessLevelOuter[gl_InvocationID] = lvls;
		gl_TessLevelInner[0] = lvls;
	}
	adapt_value_tcs[gl_InvocationID] = d;
}