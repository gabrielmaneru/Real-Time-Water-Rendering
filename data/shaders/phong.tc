#version 440

struct PhongData
{
    float termIJ;
    float termJK;
    float termIK;
};

layout(vertices=3) out;

in vec3 vNormal[];
in vec3 vTangent[];
in vec3 vBitangent[];
in vec2 vUv[];

uniform float levels = 1.0f;
uniform float lod_distance;
uniform float lod_power;
uniform bool use_adaptive;
uniform bool use_lod;
uniform mat4 M; 
uniform mat4 V; 

out vec3 Normal_tcs[3];
out vec3 Tangent_tcs[3];
out vec3 Bitangent_tcs[3];
out vec2 Uv_tcs[3];
out float adapt_value_tcs[3];
out PhongData PatchData[3];

#define Pi gl_in[0].gl_Position.xyz
#define Pj gl_in[1].gl_Position.xyz
#define Pk gl_in[2].gl_Position.xyz

float depth_value(int i)
{
	mat4 C_to_M = inverse(V*M);
	vec3 cam = (C_to_M * vec4(0,0,0,1)).xyz;
	vec3 pc = normalize(cam-gl_in[i].gl_Position.xyz);
	float n_dot_pc = dot(vNormal[i], pc);
	return 1.0-abs(n_dot_pc);
}

vec2 refinement(int i)
{
	float dp0 = depth_value(i);
	float dp1,dp2;
	if(i==0)
	{
		dp1 = depth_value(1);
		dp2 = depth_value(2);
	}
	else if(i==1)
	{
		dp1 = depth_value(2);
		dp2 = depth_value(0);
	}
	else if(i==2)
	{
		dp1 = depth_value(0);
		dp2 = depth_value(1);
	}
	return vec2(mix(dp1,dp2,0.5), (dp0+dp1+dp2)/3.0);
}

float level_of_detail()
{
	mat4 C_to_M = inverse(V*M);
	vec3 cam = (C_to_M * vec4(0,0,0,1)).xyz;
	vec3 ave =(gl_in[0].gl_Position.xyz
			 + gl_in[1].gl_Position.xyz
			 + gl_in[2].gl_Position.xyz)/3;
	float len = length(cam-ave);
	float lod = 1.0/(max(len/lod_distance,1.0));
	return pow(lod,lod_power);
}

float PI_i(int i, vec3 q)
{
	vec3 qp = q - gl_in[i].gl_Position.xyz;
	return q[gl_InvocationID] - dot(qp, vNormal[i]) * vNormal[i][gl_InvocationID];
}

void main()
{
    // pass data
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	
    Normal_tcs[gl_InvocationID] = vNormal[gl_InvocationID];
    Tangent_tcs[gl_InvocationID] = vTangent[gl_InvocationID];
    Bitangent_tcs[gl_InvocationID] = vBitangent[gl_InvocationID];
    Uv_tcs[gl_InvocationID] = vUv[gl_InvocationID];
	
	PatchData[gl_InvocationID].termIJ = PI_i(0,Pj) + PI_i(1,Pi);
	PatchData[gl_InvocationID].termJK = PI_i(1,Pk) + PI_i(2,Pj);
	PatchData[gl_InvocationID].termIK = PI_i(2,Pi) + PI_i(0,Pk);

    // set tess levels
	vec2 ref = vec2(1.0,1.0);
	if(use_adaptive)
		ref = refinement(gl_InvocationID);
	float lod = 1.0;
	if(use_lod)
		lod = level_of_detail();

	gl_TessLevelOuter[gl_InvocationID] = lod*ref.x*levels;
	gl_TessLevelInner[0] = lod*ref.y*levels;
	
	adapt_value_tcs[gl_InvocationID] = depth_value(gl_InvocationID);
}